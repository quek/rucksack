DO: 

- Handle initargs in LOAD-OBJECT and UPDATE-PERSISTENT-...

- Initialize transient slots during LOAD-OBJECT.

- Figure out if there's a better way than
    (eval-when (:compile-toplevel :load-toplevel :execute) ...)
  to make sure that class definitions within a WITH-RUCKSACK are treated
  as top level definitions.

- Maybe signal a continuable error when the in-memory class definition does
  not correspond to the most recent schema.  If the user decides to
  continue, UPDATE-PERSISTENT-INSTANCE-... will be called when necessary.

- What about in-memory persistent instances when the class definition
  changes?  We should make sure that those are updated too.  There seem
  to be three strategies:
  1. Rely on Lisp's normal UPDATE-INSTANCE-FOR-REDEFINED-CLASS mechanism.
     Then the programmer must write methods for both UPDATE-INSTANCE-...
     and UPDATE-PERSISTENT-INSTANCE-... .  That seems error prone.
  2. Remove all instances of the redefined class from the cache.
     Then the objects will be loaded from disk again, and U-P-I-F-R-C will
     be called automatically.  This has the disadvantage that all values
     of transient slots will be gone.
  3. Forbid it and signal some kind of error.

- Get rid of the PROCESS-A-CLASS-OPTION stuff and handle the :INDEX class
  option in a way that's compatible with AMOP.

- I'm not sure that :INCLUDE-SUBCLASSES NIL makes sense for
  RUCKSACK-MAP-SLOT.  Think about this.

- Does indexing in example-1 work correctly if we don't use
  *RUCKSACK* in WITH-RUCKSACK?  Maybe WITH-RUCKSACK should always
  bind *RUCKSACK*?

- There's still a btree bug that's uncovered by the stress test.
  Fix it.

- Check that btrees actually signal an error for duplicate keys.
  Handle those errors correctly for slot indexes.

- Make sure that the GC gets rid of all obsolete object versions.

- Add export/import to s-expression format.  This is necessary
  for migrating existing rucksacks to a new version of Rucksack.

- Give each transaction its own commit file (the name can be generated
  from the transaction id).  That's one step towards avoiding locks
  on transaction commit.

- Deal with CHANGE-CLASS: call UPDATE-PERSISTENT-INSTANCE-FOR-DIFFERENT-CLASS
  when necessary.  (Maybe it's never necessary and we can just use the
  existing UPDATE-INSTANCE-FOR-DIFFERENT-CLASS mechanism?)

